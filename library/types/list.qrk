(import "std:modules/math.qrk")
(import "std:types/maybe.qrk")
(data (List a) [
  Nil
  (Cons a (List a))])

(let list:empty Nil)

(defn list:length [x] (match x
  [Nil 0]
  [(Cons _ xs) (+ 1 (list:length xs))]))

(defn list:show [fmt xs] {
  (defn f [lst] (match lst
    [[] ""]
    [[x *xs] (+ (fmt x) (+ (if (= (list:length xs) 0) "" ", ") (f xs)))]
  ))
  (+ "[" (+ (f xs) "]"))
})

(defn fromList [ls] (block [
  (condition (binary (property ls "length") "===" 0)
    (return Nil))
  (return (let x (index ls 0)
    (let xs (call (property ls (var "slice")) 1)
      (Cons x (fromList xs)))))
]))

(defn list:drop [n ls] (match ls
  [(Cons _ xs) (if (= n 1) xs (list:drop (- n 1) xs))]
  [Nil Nil]))

(defn list:map [f list] (match list
  [Nil Nil]
  [(Cons x xs) (Cons (f x) (list:map f xs))]))

(defn list:iter [f x] (let _ (list:map f x) 0))

(defn list:at [x i] (match x
  [[] Nothing]
  [[y *xs] (if (= i 0) (Just y) (list:at xs (- i 1)))]))

(defn list:filter [pred list] (match list
  [Nil Nil]
  [(Cons x xs) (if (pred x) (Cons x (list:filter pred xs)) (list:filter pred xs))]))